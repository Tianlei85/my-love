<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>çˆ±çš„å›å¿†</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Microsoft YaHei", sans-serif; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-container {
            position: absolute; top: 10px; left: 10px; width: 80px; height: 106px; /* ç¼©å°è§†é¢‘æ˜¾ç¤º */
            z-index: 10; border: 1px solid #fff; border-radius: 4px; overflow: hidden;
            transform: scaleX(-1); opacity: 0.5; box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            display: none; 
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui-container {
            position: absolute; bottom: 40px; left: 0; width: 100%; 
            z-index: 20; color: #fff; pointer-events: none;
            text-align: center; display: flex; flex-direction: column; align-items: center; gap: 15px;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            opacity: 0; 
            transition: opacity 2s;
        }

        #status { 
            font-size: 14px; background: rgba(50, 50, 60, 0.6); 
            padding: 6px 15px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            transition: background 0.5s, transform 0.3s;
        }

        /* å¯åŠ¨å±å¹• */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
        }
        .start-btn {
            margin-top: 30px;
            padding: 12px 35px;
            font-size: 18px;
            background: #fff;
            border: none; border-radius: 50px;
            color: #000; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ccc; font-size: 14px; z-index: 100; text-align: center;
            display: none;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-weight: 300; margin-bottom: 10px; font-size: 24px;">âœ¨ åœ£è¯æ˜Ÿå…‰å›å¿† âœ¨</h1>
        <p style="font-size: 13px; opacity: 0.7; max-width: 80%;">Liteç‰ˆ - ä¸“ä¸º iOS ä¼˜åŒ–<br>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å¯</p>
        <button class="start-btn" onclick="initExperience()">å¼€å¯å›å¿†</button>
    </div>

    <div id="loading" class="loading">
        æ­£åœ¨è§£å‹å›å¿†...
    </div>

    <div id="video-container">
        <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    </div>
    
    <div id="ui-container">
        <div id="status">â³ æ˜Ÿå…‰æ±‡èšä¸­...</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        // ç§»é™¤åæœŸå¤„ç†æ¨¡å—ä»¥èŠ‚çœå¤§é‡å†…å­˜
        // import { EffectComposer } ...
        // import { RenderPass } ...
        // import { UnrealBloomPass } ...
        import { Water } from 'three/addons/objects/Water.js';

        const MAX_PHOTO_CHECK = 100; 
        const borderTextureCache = {};
        
        // å†…å­˜ä¼˜åŒ–ï¼šç”¨äºå‹ç¼©å›¾ç‰‡çš„ä¸´æ—¶ç”»å¸ƒ
        const resizerCanvas = document.createElement('canvas');
        resizerCanvas.width = 256; // å¼ºåˆ¶å‹ç¼©åˆ°256x256
        resizerCanvas.height = 256;
        const resizerCtx = resizerCanvas.getContext('2d', { willReadFrequently: true });

        // --- 1. åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 
        // å‡å°‘é›¾çš„è®¡ç®—
        scene.fog = new THREE.FogExp2(0x000000, 0.005); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // é™ä½è¿œè£é¢
        function adjustCamera() {
            camera.position.set(0, 2, window.innerHeight > window.innerWidth ? 50 : 35);
        }
        adjustCamera();

        // å…³é”®ä¼˜åŒ–ï¼šå¼ºåˆ¶ pixelRatio ä¸º 1ï¼Œç¦æ­¢ iOS ä½¿ç”¨ 3å€è§†ç½‘è†œæ¸²æŸ“
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "default" }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); 
        // ç§»é™¤å¤æ‚çš„è‰²è°ƒæ˜ å°„ï¼Œä½¿ç”¨æœ€åŸºç¡€çš„
        renderer.toneMapping = THREE.NoToneMapping;
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5)); // è°ƒäº®ç¯å¢ƒå…‰ï¼Œå¼¥è¡¥å»é™¤Bloomåçš„æš—æ·¡
        
        const centerLight = new THREE.PointLight(0xffffff, 1.5, 40); 
        centerLight.position.set(0, 5, 5);
        scene.add(centerLight);

        // --- 2. æç®€æ°´é¢ (ç§»é™¤åå°„è®¡ç®—) ---
        // iOSä¸Š Water çš„åå°„éå¸¸è€—æ€§èƒ½ï¼Œè¿™é‡Œä½¿ç”¨ç®€åŒ–ç‰ˆé…ç½®
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000); 
        const waterNormals = new THREE.TextureLoader().load('https://unpkg.com/three@0.160.0/examples/textures/water/Water_1_M_Normal.jpg', function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        });

        const water = new Water(
            waterGeometry,
            {
                textureWidth: 128, // æä½åˆ†è¾¨ç‡åå°„
                textureHeight: 128,
                waterNormals: waterNormals,
                sunDirection: new THREE.Vector3(5, 5, -10).normalize(), 
                sunColor: 0xffffff, 
                waterColor: 0x001e0f, 
                distortionScale: 0, 
                fog: false // å…³é—­æ°´é¢é›¾æ•ˆ
            }
        );
        water.rotation.x = -Math.PI / 2;
        water.position.y = -13; 
        scene.add(water);

        // --- 3. è¾¹æ¡†çº¹ç† (æå°å°ºå¯¸) ---
        function getBorderTexture(colorHex) {
            if (borderTextureCache[colorHex]) return borderTextureCache[colorHex];
            
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; // å†æ¬¡ç¼©å°
            const ctx = canvas.getContext('2d');
            
            // ç®€å•ç”»ä¸€ä¸ªæ¡†ï¼Œå»é™¤é˜´å½±æ¨¡ç³Šè®¡ç®—
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#000000';
            ctx.fillRect(2,2,60,60);

            const texture = new THREE.CanvasTexture(canvas);
            borderTextureCache[colorHex] = texture;
            return texture;
        }

        // ç®€å•çš„å‘å…‰çº¹ç†ï¼Œæ›¿ä»£ Shader
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); 
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const glowTexture = createGlowTexture();

        function createPlaceholderTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#333'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#fff'; ctx.fillText("No IMG", 10, 35);
            return new THREE.CanvasTexture(canvas);
        }

        // --- æ–‡å­—ç²’å­ ---
        const TEXT_POINTS = [];
        function generateTextPositions() {
            // å‡å°‘æ–‡å­—ç²’å­æ•°é‡
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 350; canvas.height = 375; // ç”»å¸ƒå‡åŠ
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,350,375);
            ctx.font = 'bold 65px "Microsoft YaHei"'; // å­—ä½“å‡åŠ
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText("å®", 100, 110); ctx.fillText("å®", 100, 185);
            ctx.fillText("æˆ‘", 250, 60); ctx.fillText("çˆ±", 250, 135); ctx.fillText("ä½ ", 250, 210);
            ctx.fillStyle = '#FFC6D5'; ctx.fillText("â¤", 250, 285);
            
            const data = ctx.getImageData(0,0,350,375).data;
            // é‡‡æ ·æ­¥é•¿å¢åŠ ï¼Œç²’å­æ›´å°‘
            const step = 4; 
            for(let y=0; y<375; y+=step) {
                for(let x=0; x<350; x+=step) {
                    if(data[(y*350+x)*4] > 64) {
                        const isPink = data[(y*350+x)*4+1] < 200;
                        TEXT_POINTS.push({
                            // åæ ‡é‡æ–°æ”¾å¤§å›åŸæ¯”ä¾‹
                            vec: new THREE.Vector3((x-175)*0.09, -(y-187)*0.09+7.5, (Math.random()-0.5)),
                            color: isPink ? 0xFFC6D5 : 0xffffff
                        });
                    }
                }
            }
        }
        generateTextPositions();

        const particlesGroup = new THREE.Group();
        scene.add(particlesGroup);
        const particles = [];
        const PARTICLE_COUNT = 2000; // å‡å°‘ç²’å­æ€»æ•° (3500 -> 2000)
        const photoGeo = new THREE.PlaneGeometry(1, 1);
        
        // --- ç®€åŒ–çš„èƒŒæ™¯æ˜Ÿæ˜Ÿ ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) {
            const x = (Math.random()-0.5)*400;
            const y = (Math.random()-0.5)*400;
            const z = (Math.random()-0.5)*400;
            starPos.push(x,y,z);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 2, map: glowTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);

        function createTopStar() {
            const mat = new THREE.SpriteMaterial({ map: glowTexture, color: 0xffff00 });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(0,0,1); sprite.position.set(0,15.5,0);
            sprite.userData = { isTopStar: true, currentScale: 0 };
            particlesGroup.add(sprite);
        }
        createTopStar();

        function createParticle(isFixedImage = false, texture = null, imgRatio = 1.0) {
            let mesh;
            let isImage = false;
            let targetPos; 
            const ratio = Math.random(); 
            const h = ratio * 24.5 - 11; 
            let maxR = 10 * Math.pow(1 - ratio, 0.8);
            maxR *= (0.8 + 0.2 * Math.sin(ratio * Math.PI * 14));
            let r = maxR * (0.2 + 0.8 * Math.sqrt(Math.random()));
            if (isFixedImage) r *= 1.2; 
            const angle = Math.random() * Math.PI * 2;
            targetPos = new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r);
            
            let textTargetPos;
            let finalScale = new THREE.Vector3();
            
            if (isFixedImage && texture) {
                mesh = new THREE.Group();
                isImage = true;
                // ä»…ç”¨ä¸€ä¸ªMeshï¼Œå»é™¤è¾¹æ¡† Mesh ä»¥å‡å°‘ Draw Calls
                const photoMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide 
                });
                const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                // ç®€å•çš„ç™½è‰²èƒŒæ™¯æ¨¡æ‹Ÿè¾¹æ¡†
                const bgGeo = new THREE.PlaneGeometry(1.1, 1.1);
                const bgMat = new THREE.MeshBasicMaterial({color: 0xffffff});
                const bgMesh = new THREE.Mesh(bgGeo, bgMat);
                bgMesh.position.z = -0.01;
                mesh.add(bgMesh);
                mesh.add(photoMesh);

                finalScale.set(0.015 * imgRatio, 0.015, 0.015);
                const pAngle = Math.random() * Math.PI * 2;
                const pR = 18 + Math.random() * 6; 
                const pY = (Math.random() - 0.5) * 20 + 7.5; 
                textTargetPos = new THREE.Vector3(Math.cos(pAngle)*pR, pY, Math.sin(pAngle)*pR);
            } else {
                if (particles.length < TEXT_POINTS.length) {
                    const pt = TEXT_POINTS[particles.length];
                    textTargetPos = pt.vec;
                    var particleColor = pt.color;
                } else {
                    const bgAngle = Math.random() * Math.PI * 2;
                    const bgR = 25 + Math.random() * 20;
                    const bgY = (Math.random() - 0.5) * 30 + 5;
                    textTargetPos = new THREE.Vector3(Math.cos(bgAngle)*bgR, bgY, Math.sin(bgAngle)*bgR);
                    var particleColor = (Math.random() < 0.15) ? 0xFFC6D5 : 0xffffff;
                }
                const mat = new THREE.SpriteMaterial({
                    map: glowTexture, color: particleColor, transparent: true, opacity: 0.6
                });
                mesh = new THREE.Sprite(mat);
                const s = 0.15 + Math.random() * 0.3;
                finalScale.set(s, s, s);
            }
            mesh.position.set((Math.random()-0.5)*60, 40+Math.random()*40, (Math.random()-0.5)*60);
            mesh.scale.set(0, 0, 0); 
            particlesGroup.add(mesh);
            return { mesh, treePos: targetPos, textPos: textTargetPos, isImage, state: 'free', ratio: imgRatio, finalScale };
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(createParticle(false));

        const loader = new THREE.TextureLoader();
        let successfulPhotos = 0;
        let checkedCount = 0;

        function checkAllChecked() {
            checkedCount++;
            if(checkedCount >= MAX_PHOTO_CHECK) {
                if (successfulPhotos === 0) {
                    const placeholder = createPlaceholderTexture();
                    for(let k=0; k<20; k++) particles.push(createParticle(true, placeholder, 1.0));
                }
                setTimeout(playIntro, 500);
            }
        }

        // æ ¸å¿ƒä¿®å¤ï¼šçº¹ç†é‡é‡‡æ ·é€»è¾‘
        function processLoadedTexture(tex) {
            // 1. å°†å¤§å›¾ç”»åˆ° 256x256 çš„ç”»å¸ƒä¸Š
            resizerCtx.clearRect(0, 0, 256, 256);
            // ä¿æŒæ¯”ä¾‹ç»˜åˆ¶
            let ratio = 1.0;
            if(tex.image) {
                ratio = tex.image.width / tex.image.height;
                // ç»˜åˆ¶åˆ°å°ç”»å¸ƒ
                resizerCtx.drawImage(tex.image, 0, 0, 256, 256);
            }
            
            // 2. ä»ç”»å¸ƒåˆ›å»ºæ–°çº¹ç†
            const smallTex = new THREE.CanvasTexture(resizerCanvas);
            smallTex.colorSpace = THREE.SRGBColorSpace;
            
            // 3. é”€æ¯åŸå§‹å¤§çº¹ç†ï¼Œé‡Šæ”¾å†…å­˜
            tex.dispose();

            for(let k=0; k<5; k++) particles.push(createParticle(true, smallTex, ratio));
            successfulPhotos++;
            checkAllChecked();
        }

        window.initExperience = async function() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            await startCamera();
            
            // å»¶è¿Ÿä¸€ç‚¹ç‚¹åŠ è½½å›¾ç‰‡ï¼Œé˜²æ­¢CPUç¬æ—¶è·‘æ»¡
            setTimeout(loadPhotos, 100);
        };

        function loadPhotos() {
            // é™åˆ¶å¹¶å‘åŠ è½½ï¼Œè™½ç„¶æµè§ˆå™¨æœ‰å¹¶å‘é™åˆ¶ï¼Œä½†æˆ‘ä»¬è¿™é‡Œè¿˜æ˜¯ç®€å•å¤„ç†å¾ªç¯
            // å¦‚æœä¸ºäº†æè‡´ç¨³å®šï¼Œå¯ä»¥ç”¨é€’å½’é€ä¸ªåŠ è½½ï¼Œä½†è¿™é‡Œç”¨forå¾ªç¯+å°å›¾æ–¹æ¡ˆåº”è¯¥è¶³å¤Ÿ
            for(let i=1; i<=MAX_PHOTO_CHECK; i++) {
                loader.load(
                    `${i}.JPG`, 
                    (tex) => { processLoadedTexture(tex); }, 
                    undefined, 
                    (err) => {
                        loader.load(
                            `${i}.jpg`, 
                            (tex) => { processLoadedTexture(tex); },
                            undefined,
                            (err2) => { checkAllChecked(); }
                        );
                    }
                );
            }
        }
        
        let sceneState = 'OPENING'; 
        function playIntro() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui-container').style.opacity = 1;
            document.getElementById('video-container').style.display = 'block';

            particles.forEach(p => {
                const delay = Math.random() * 2.0; // å‡å°‘ç­‰å¾…æ—¶é—´
                const duration = 2.0;
                gsap.to(p.mesh.position, { x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, duration: duration, delay: delay, ease: "power2.out" });
                gsap.to(p.mesh.scale, { x: p.finalScale.x, y: p.finalScale.y, z: p.finalScale.z, duration: 1.5, delay: delay });
                if (p.isImage) {
                    p.mesh.rotation.z = Math.random() * Math.PI;
                    gsap.to(p.mesh.rotation, { z: 0, duration: duration, delay: delay });
                }
            });

            particlesGroup.children.forEach(child => {
                if(child.userData.isTopStar) {
                    child.userData.currentScale = 3.5; 
                    gsap.to(child.scale, { x: 3.5, y: 3.5, duration: 1.5, delay: 3.0 });
                }
            });

            setTimeout(() => {
                sceneState = 'TREE';
                const statusDiv = document.getElementById('status');
                statusDiv.innerText = "âœŠ æ¡æ‹³: è—å…¥å¿ƒåº• | ğŸ– å¼ å¼€: å¤§å£°è¯´çˆ±ä½ ";
                gsap.from(statusDiv, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });
            }, 5000); 
        }

        let isPinching = false;
        let rotationSpeed = 0.005; 
        const BASE_SPEED = 0.005;
        let lastPalmX = null; 
        let heldParticle = null; 
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            water.material.uniforms['time'].value += 1.0 / 60.0;
            centerLight.position.x = Math.sin(time * 0.5) * 3;

            if (sceneState !== 'OPENING') {
                particlesGroup.children.forEach(child => {
                    if(child.userData.isTopStar) {
                        let targetScale = 3.5; 
                        if (sceneState === 'EXPLODE') targetScale = 0.0; 
                        child.scale.set(targetScale, targetScale, 1);
                    }
                });
            }

            if (!heldParticle) {
                particlesGroup.rotation.y += rotationSpeed;
                if (sceneState === 'EXPLODE') rotationSpeed *= 0.95;
                else rotationSpeed += (BASE_SPEED - rotationSpeed) * 0.05;
            }

            particles.forEach((p) => {
                if (sceneState === 'OPENING') return;
                if (p.state === 'grabbed') { p.mesh.lookAt(camera.position); return; }
                const target = (sceneState === 'TREE') ? p.treePos : p.textPos;
                p.mesh.position.lerp(target, 0.1); // åŠ å¿«æ’å€¼ï¼Œå‡å°‘è®¡ç®—
                if (p.isImage) {
                    p.mesh.lookAt(camera.position); 
                } 
            });
            renderer.render(scene, camera); // ç›´æ¥æ¸²æŸ“ï¼Œä¸ç»è¿‡Composer
        }
        animate();

        const videoElement = document.getElementById('input-video');
        const statusDiv = document.getElementById('status');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        // é™ä½AIæ¨¡å‹å¤æ‚åº¦
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        function onResults(results) {
            if (sceneState === 'OPENING') return;
            if (!results.multiHandLandmarks?.length) {
                lastPalmX = null; if (heldParticle) releaseCurrentParticle(); return;
            }
            const lm = results.multiHandLandmarks[0];
            const thumb = lm[4]; const index = lm[8]; const wrist = lm[0];
            const currentPalmX = lm[9].x; 
            if (lastPalmX !== null && !isPinching) {
                const deltaX = currentPalmX - lastPalmX;
                if (Math.abs(deltaX) > 0.002) rotationSpeed -= deltaX * 0.8; 
            }
            lastPalmX = currentPalmX;
            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            let spread = 0;
            [lm[8], lm[12], lm[16], lm[20]].forEach(t => spread += Math.hypot(t.x - wrist.x, t.y - wrist.y));
            spread /= 4;
            if (!isPinching) {
                if (spread < 0.22) { sceneState = 'TREE'; } else { sceneState = 'EXPLODE'; }
            }
            if (pinchDist < 0.05) {
                if (sceneState === 'EXPLODE') { isPinching = true; if (!heldParticle) grabNewParticle(); }
            } else {
                isPinching = false; if (heldParticle) releaseCurrentParticle();
            }
            if (sceneState === 'TREE') {
                statusDiv.innerText = "ğŸ– å¼ å¼€ï¼šå¤§å£°è¯´çˆ±ä½ ";
            } else {
                statusDiv.innerText = isPinching ? "ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç¾å¥½ç¬é—´" : "âœŠ æ¡æ‹³ï¼šè—å…¥å¿ƒåº•";
            }
        }

        function grabNewParticle() {
            let candidates = particles.filter(p => p.isImage && p.state === 'free');
            if (candidates.length === 0) candidates = particles.filter(p => p.state === 'free');
            if (candidates.length > 0) {
                const p = candidates[Math.floor(Math.random() * candidates.length)];
                p.state = 'grabbed'; heldParticle = p; scene.attach(p.mesh); 
                p.mesh.renderOrder = 9999;
                gsap.to(p.mesh.position, { x: 0, y: 4, z: 20, duration: 0.5 });
                const s = p.isImage ? 8 * p.ratio : 6;
                gsap.to(p.mesh.scale, { x: s, y: s, z: s, duration: 0.5 });
            }
        }
        function releaseCurrentParticle() {
            if (!heldParticle) return;
            const p = heldParticle; p.state = 'free'; heldParticle = null; p.mesh.renderOrder = 0;
            particlesGroup.attach(p.mesh);
            const s = p.isImage ? 0.015 : (0.15 + Math.random()*0.3);
            const fs = p.isImage ? s * p.ratio : s;
            gsap.to(p.mesh.scale, { x: fs, y: s, z: s, duration: 0.5 });
        }

        async function startCamera() {
            try {
                // è¯·æ±‚æä½åˆ†è¾¨ç‡çš„è§†é¢‘æµ
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 160, height: 120, facingMode: 'user', frameRate: { ideal: 10, max: 15 } }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    requestAnimationFrame(processVideo);
                };
            } catch (err) {
                console.warn(err);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œæ‰‹åŠ¿åŠŸèƒ½ä¸å¯ç”¨ã€‚");
            }
        }

        let lastTime = 0;
        async function processVideo() {
            if (videoElement.paused || videoElement.ended) return;
            const now = Date.now();
            // èŠ‚æµï¼šæ¯ 150ms æ£€æµ‹ä¸€æ¬¡æ‰‹åŠ¿ (çº¦ 6-7 FPS)ï¼Œè¶³å¤Ÿäº¤äº’ä¸”æå¤§èŠ‚çœæ€§èƒ½
            if (now - lastTime > 150) {
                if (videoElement.readyState >= 2) await hands.send({image: videoElement});
                lastTime = now;
            }
            requestAnimationFrame(processVideo);
        }

        window.addEventListener('resize', () => {
            adjustCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
