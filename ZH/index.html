<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>çˆ±çš„å›å¿†</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Microsoft YaHei", sans-serif; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-container {
            position: absolute; top: 10px; left: 10px; width: 100px; height: 133px;
            z-index: 10; border: 2px solid #fff; border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); opacity: 0.6; box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            display: none; 
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui-container {
            position: absolute; bottom: 40px; left: 0; width: 100%; 
            z-index: 20; color: #fff; pointer-events: none;
            text-align: center; display: flex; flex-direction: column; align-items: center; gap: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.9);
            opacity: 0; 
            transition: opacity 2s;
        }

        #status { 
            font-size: 15px; background: rgba(50, 50, 60, 0.4); 
            padding: 8px 20px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px); color: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            transition: background 0.5s, transform 0.3s;
        }

        /* --- å¯åŠ¨å±å¹•ä¸å¼€é—¨ç‰¹æ•ˆ CSS --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            perspective: 1200px; /* 3D é€è§† */
            overflow: hidden;
            transition: opacity 1.5s ease-in;
        }

        #welcome-text {
            font-size: 32px;
            font-weight: 900; /* å­—ä½“åŠ ç²— */
            letter-spacing: 3px;
            margin-bottom: 50px;
            
            /* æ¸å˜ç²‰è‰²æ–‡å­—æ•ˆæœ */
            background: linear-gradient(180deg, #ffffff 0%, #ff9a9e 60%, #ff758c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            
            /* æ–‡å­—å‘å…‰ */
            filter: drop-shadow(0 0 10px rgba(255, 154, 158, 0.5));
            
            animation: floatText 2.5s ease-in-out infinite;
            transition: opacity 0.5s, transform 0.5s;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* é—¨çš„å®¹å™¨ */
        .door-wrapper {
            position: relative;
            width: 160px;
            height: 260px;
            transform-style: preserve-3d;
            /* é•œå¤´æ¨è¿›åŠ¨ç”»ï¼šå»¶è¿Ÿ0.2ç§’æ‰§è¡Œï¼Œè®©é—¨å…ˆå¼€ä¸€ç‚¹ */
            transition: transform 2.5s cubic-bezier(0.7, 0, 0.2, 1); 
        }

        /* é—¨æ¿ä¸»ä½“ */
        .door-btn {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
            border: 4px solid #fff;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 40px rgba(255, 154, 158, 0.5), 
                inset 0 0 20px rgba(255,255,255,0.4);
            
            /* æ—‹è½¬è½´åœ¨å·¦ä¾§ */
            transform-origin: left center; 
            /* å¼€é—¨åŠ¨ç”»ï¼šç«‹å³æ‰§è¡Œ */
            transition: transform 1.8s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s;
            transform-style: preserve-3d;
        }

        .door-btn:hover {
            box-shadow: 0 0 60px rgba(255, 154, 158, 0.9);
        }

        /* é—¨ä¸Šçš„æ–‡å­— */
        .door-text {
            color: #7a3e3e;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 5px;
            writing-mode: vertical-rl; /* ç«–æ’æ–‡å­— */
            text-orientation: upright;
            opacity: 0.9;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }

        /* é—¨æŠŠæ‰‹ */
        .door-knob {
            position: absolute;
            right: 18px;
            top: 50%;
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
            border-radius: 50%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        /* --- åŠ¨ç”»çŠ¶æ€ç±» --- */
        
        /* 1. éšè—æ¬¢è¿è¯­ */
        .fade-out-text {
            opacity: 0 !important;
            transform: translateY(-20px) !important;
        }

        /* 2. é—¨æ¿æ—‹è½¬æ‰“å¼€ (å…ˆæ‰§è¡Œ) */
        .door-open {
            transform: rotateY(-120deg); /* å‘å†…å¤§å¹…æ‰“å¼€ */
        }

        /* 3. é•œå¤´æ¨è¿›æ”¾å¤§ (ç¨åæ‰§è¡Œ) */
        .camera-zoom {
            /* å»¶è¿Ÿ0.3ç§’ï¼Œç­‰é—¨å¼€ä¸€æ¡ç¼åå†å†²è¿›å» */
            transition-delay: 0.3s !important; 
            transform: scale(15) translateZ(200px); /* æ”¾å¤§å€æ•°å¢åŠ  */
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 16px; z-index: 100; text-align: center; line-height: 1.6;
            text-shadow: 0 0 10px #fff;
            transition: opacity 0.5s;
            display: none;
        }
    </style>
</head>
<body>

    <!-- ç›´æ¥æ˜¾ç¤ºå¤§é—¨ -->
    <div id="start-screen">
        <h1 id="welcome-text">å®å®è¯·è¿›</h1>
        
        <div class="door-wrapper" id="door-scene">
            <div class="door-btn" onclick="openDoorAndEnter()">
                <div class="door-text">å¼€é—¨</div>
                <div class="door-knob"></div>
            </div>
        </div>
    </div>

    <div id="loading" class="loading">
        âœ¨ æ­£åœ¨ç‚¹äº®æ˜Ÿå…‰...
    </div>

    <div id="video-container">
        <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    </div>
    
    <div id="ui-container">
        <div id="status">â³ æ˜Ÿå…‰æ±‡èšä¸­...</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Water } from 'three/addons/objects/Water.js';

        const MAX_PHOTO_CHECK = 100; 
        const borderTextureCache = {};

        // --- 1. åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 
        scene.fog = new THREE.FogExp2(0x000000, 0.005); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        function adjustCamera() {
            camera.position.set(0, 2, window.innerHeight > window.innerWidth ? 50 : 35);
        }
        adjustCamera();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.2)); 
        
        const centerLight = new THREE.PointLight(0xffffff, 2.0, 50); 
        centerLight.position.set(0, 5, 5);
        scene.add(centerLight);

        // --- 2. é™è°§é•œæ¹– ---
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000); 

        const waterNormals = new THREE.TextureLoader().load('https://unpkg.com/three@0.160.0/examples/textures/water/Water_1_M_Normal.jpg', function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        });

        const water = new Water(
            waterGeometry,
            {
                textureWidth: window.innerWidth * Math.min(window.devicePixelRatio, 2) * 0.5, 
                textureHeight: window.innerHeight * Math.min(window.devicePixelRatio, 2) * 0.5,
                waterNormals: waterNormals,
                sunDirection: new THREE.Vector3(5, 5, -10).normalize(), 
                sunColor: 0xffffff, 
                waterColor: 0x001e0f, 
                distortionScale: 0, 
                fog: scene.fog !== undefined
            }
        );

        water.rotation.x = -Math.PI / 2;
        water.position.y = -13; 
        water.material.uniforms.size.value = 1.0; 
        scene.add(water);

        // --- Bloom (æ³›å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomResolution = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
        const bloomPass = new UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.5; 
        bloomPass.strength = 0.9; 
        bloomPass.radius = 0.8;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. çº¹ç†ç”Ÿæˆ ---
        function getBorderTexture(colorHex) {
            if (borderTextureCache[colorHex]) return borderTextureCache[colorHex];
            
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            const r = (colorHex >> 16) & 255;
            const g = (colorHex >> 8) & 255;
            const b = colorHex & 255;

            function drawRoundRectPath(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            }

            const padding = 6; 
            const w = 128 - padding * 2;
            const h = 128 - padding * 2;
            const x = padding;
            const y = padding;
            const cornerRadius = 3; 

            ctx.clearRect(0, 0, 128, 128);

            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
            ctx.lineWidth = 2;
            drawRoundRectPath(x, y, w, h, cornerRadius);
            ctx.stroke();

            ctx.shadowBlur = 3; 
            ctx.shadowColor = `rgba(255, 255, 255, 0.5)`;
            ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`; 
            ctx.lineWidth = 1;
            drawRoundRectPath(x, y, w, h, cornerRadius);
            ctx.stroke();

            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'black';
            const inset = 2;
            drawRoundRectPath(x + inset, y + inset, w - inset*2, h - inset*2, cornerRadius - 1);
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';

            const texture = new THREE.CanvasTexture(canvas);
            borderTextureCache[colorHex] = texture;
            return texture;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); 
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); 
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; 
            const ctx = canvas.getContext('2d');
            const cx = 32, cy = 32, spikes = 5, outerRadius = 30, innerRadius = 12;
            let rot = Math.PI / 2 * 3;
            let x = cx, y = cy;
            const step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
            grad.addColorStop(0, '#ffffff');
            grad.addColorStop(1, '#cccccc');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.shadowColor = "white";
            ctx.shadowBlur = 10;
            ctx.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        const glowTexture = createGlowTexture();
        const starTexture = createStarTexture();

        function createPlaceholderTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000'; 
            ctx.fillRect(0,0,128,128);
            ctx.strokeStyle = '#fff'; 
            ctx.lineWidth = 2; 
            ctx.strokeRect(3,3,122,122);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 15px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("ç¾å¥½å›å¿†", 64, 50);
            ctx.font = '10px sans-serif';
            ctx.fillStyle = '#ccc';
            ctx.fillText(text, 64, 75);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- ç”Ÿæˆæ–‡å­—ç²’å­åæ ‡ ---
        const TEXT_POINTS = [];
        function generateTextPositions() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 700;
            canvas.height = 750;
            ctx.fillStyle = '#000000'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 130px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const lineHeight = 150;
            const startY = 120;
            ctx.fillStyle = '#ffffff'; 
            const col1X = 200; 
            ctx.fillText("å®", col1X, startY + lineHeight * 1); 
            ctx.fillText("å®", col1X, startY + lineHeight * 2);
            const col2X = 500; 
            ctx.fillText("æˆ‘", col2X, startY);
            ctx.fillText("çˆ±", col2X, startY + lineHeight * 1);
            ctx.fillText("ä½ ", col2X, startY + lineHeight * 2);
            ctx.fillStyle = '#FFC6D5'; 
            ctx.fillText("â¤", col2X, startY + lineHeight * 3);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const step = 5; 
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];

                    if (r > 64) {
                        const posX = (x - canvas.width / 2) * 0.045; 
                        const posY = -(y - canvas.height / 2) * 0.045 + 7.5; 
                        const posZ = (Math.random() - 0.5) * 1.5;
                        let pColor = 0xffffff;
                        if (g < 240) { pColor = 0xFFC6D5; }
                        TEXT_POINTS.push({
                            vec: new THREE.Vector3(posX, posY, posZ),
                            color: pColor
                        });
                    }
                }
            }
        }
        generateTextPositions();

        const particlesGroup = new THREE.Group();
        scene.add(particlesGroup);
        const particles = [];
        const PARTICLE_COUNT = 3500; 
        const photoGeo = new THREE.PlaneGeometry(1, 1);
        
        // --- èƒŒæ™¯æ˜Ÿç©º ---
        const starCount = 2000;
        const starGeo = new THREE.BufferGeometry();
        const starPositions = [];
        const starSizes = [];
        const starPhases = [];

        for(let i=0; i<starCount; i++) {
            const r = 200 + Math.random() * 300; 
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            starPositions.push(x, y, z);
            starSizes.push(Math.random() * 4.0 + 2.0); 
            starPhases.push(Math.random() * Math.PI * 2);
        }

        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
        starGeo.setAttribute('phase', new THREE.Float32BufferAttribute(starPhases, 1));

        const starMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                pointTexture: { value: glowTexture },
                uTime: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                attribute float phase;
                varying float vOpacity;
                uniform float uTime;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    float twinkle = 0.6 + 0.4 * sin(uTime * 1.5 + phase);
                    vOpacity = twinkle;
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform sampler2D pointTexture;
                varying float vOpacity;
                void main() {
                    gl_FragColor = vec4(color, vOpacity);
                    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const starSystem = new THREE.Points(starGeo, starMaterial);
        scene.add(starSystem);

        function createTopStar() {
            const mat = new THREE.SpriteMaterial({
                map: starTexture, 
                color: 0xffffff, 
                transparent: true, 
                blending: THREE.AdditiveBlending,
                opacity: 0 
            });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(0, 0, 1); 
            sprite.position.set(0, 15.5, 0); 
            sprite.userData = { isTopStar: true, currentAlpha: 0, currentScale: 0 };
            particlesGroup.add(sprite);
        }
        createTopStar();

        // --- æ ¸å¿ƒï¼šåˆ›å»ºç²’å­ (ä¿æŒä¸‹æ²‰åˆ†å¸ƒé€»è¾‘) ---
        function createParticle(isFixedImage = false, texture = null, imgRatio = 1.0) {
            let mesh;
            let isImage = false;
            let targetPos; 

            const ratio = Math.pow(Math.random(), 1.8); 
            const h = ratio * 24.5 - 11; 
            let maxR = 12 * Math.pow(1 - ratio, 0.9);
            maxR *= (0.8 + 0.2 * Math.sin(ratio * Math.PI * 14));
            let r = maxR * (0.2 + 0.8 * Math.sqrt(Math.random()));

            if (isFixedImage) r *= 1.2; 
            const angle = Math.random() * Math.PI * 2;
            targetPos = new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r);
            
            let textTargetPos;
            let finalScale = new THREE.Vector3();
            
            if (isFixedImage && texture) {
                mesh = new THREE.Group();
                isImage = true;
                const borderTex = getBorderTexture(0xffffff); 
                const borderMat = new THREE.MeshBasicMaterial({ 
                    map: borderTex, color: 0xffffff, transparent: true,
                    opacity: 1.0, side: THREE.DoubleSide, depthWrite: false
                }); 
                const borderMesh = new THREE.Mesh(photoGeo, borderMat);
                borderMesh.scale.set(1.1, 1.1, 1.0); 
                borderMesh.position.z = -0.01; 
                mesh.add(borderMesh);
                const photoMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    color: 0xcccccc, 
                    side: THREE.DoubleSide, 
                    transparent: true
                });
                const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                photoMesh.position.z = 0.01;
                mesh.add(photoMesh);
                finalScale.set(0.015 * imgRatio, 0.015, 0.015);
                const pAngle = Math.random() * Math.PI * 2;
                const pR = 18 + Math.random() * 6; 
                const pY = (Math.random() - 0.5) * 20 + 7.5; 
                textTargetPos = new THREE.Vector3(Math.cos(pAngle)*pR, pY, Math.sin(pAngle)*pR);
            } else {
                if (particles.length < TEXT_POINTS.length) {
                    const pt = TEXT_POINTS[particles.length];
                    textTargetPos = pt.vec;
                    var particleColor = pt.color;
                } else {
                    const bgAngle = Math.random() * Math.PI * 2;
                    const bgR = 25 + Math.random() * 20;
                    const bgY = (Math.random() - 0.5) * 30 + 5;
                    textTargetPos = new THREE.Vector3(Math.cos(bgAngle)*bgR, bgY, Math.sin(bgAngle)*bgR);
                    const isPink = Math.random() < 0.15;
                    var particleColor = isPink ? 0xFFC6D5 : 0xffffff;
                }
                const mat = new THREE.SpriteMaterial({
                    map: glowTexture, 
                    color: particleColor, 
                    transparent: true, opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                mesh = new THREE.Sprite(mat);
                const s = 0.15 + Math.random() * 0.3;
                finalScale.set(s, s, s);
            }
            mesh.position.set(
                (Math.random() - 0.5) * 60, 
                40 + Math.random() * 40,    
                (Math.random() - 0.5) * 60  
            );
            mesh.scale.set(0, 0, 0); 
            particlesGroup.add(mesh);
            return {
                mesh, treePos: targetPos, textPos: textTargetPos, isImage, state: 'free', ratio: imgRatio, phase: Math.random() * Math.PI * 2, finalScale: finalScale 
            };
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(createParticle(false));

        const loader = new THREE.TextureLoader();
        let successfulPhotos = 0;
        let checkedCount = 0;

        function checkAllChecked() {
            checkedCount++;
            if(checkedCount >= MAX_PHOTO_CHECK) {
                if (successfulPhotos === 0) {
                    const placeholder = createPlaceholderTexture("æ²¡æœ‰ç…§ç‰‡");
                    for(let k=0; k<20; k++) particles.push(createParticle(true, placeholder, 1.0));
                }
                document.getElementById('loading').style.display = 'none'; 
            }
        }

        function processLoadedTexture(tex) {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.generateMipmaps = true;
            
            let ratio = 1.0;
            if(tex.image && tex.image.width && tex.image.height) {
                ratio = tex.image.width / tex.image.height;
            }
            for(let k=0; k<5; k++) particles.push(createParticle(true, tex, ratio));
            successfulPhotos++;
            checkAllChecked();
        }

        // --- æ ¸å¿ƒï¼šå¼€é—¨å¹¶å¯åŠ¨ä½“éªŒ ---
        window.openDoorAndEnter = async function() {
            // 1. æ–‡æœ¬æ¶ˆå¤±
            const textEl = document.getElementById('welcome-text');
            if(textEl) textEl.classList.add('fade-out-text');

            // 2. é—¨åŠ¨ç”» (å¼€é—¨ + æ”¾å¤§)
            const doorBtn = document.querySelector('.door-btn');
            const doorScene = document.getElementById('door-scene');
            
            if(doorBtn) doorBtn.classList.add('door-open');
            if(doorScene) doorScene.classList.add('camera-zoom');

            // 3. åŒæ—¶ç”³è¯·æƒé™å¹¶åŠ è½½ (æµè§ˆå™¨è¦æ±‚åœ¨ç‚¹å‡»äº‹ä»¶ä¸­è°ƒç”¨ getUserMedia)
            const loading = document.getElementById('loading');
            
            // å»¶è¿Ÿä¸€ç‚¹æ˜¾ç¤ºloadingï¼Œé¿å…ç ´ååŠ¨ç”»
            setTimeout(() => { loading.style.display = 'block'; }, 1000);

            // å¯åŠ¨åŠ è½½å’Œæ‘„åƒå¤´
            loadPhotos();
            await startCamera();

            // 4. è½¬åœºï¼šéšè—é—¨ï¼Œæ˜¾ç¤ºåœºæ™¯
            setTimeout(() => {
                const startScreen = document.getElementById('start-screen');
                startScreen.style.opacity = 0;
                
                playIntro(); // å¼€å§‹ç²’å­åŠ¨ç”»
                
                setTimeout(() => startScreen.style.display = 'none', 1500);
            }, 2500); // ç•™è¶³æ—¶é—´ç»™â€œç©¿è¿‡é—¨â€çš„åŠ¨ç”»
        };

        function loadPhotos() {
            for(let i=1; i<=MAX_PHOTO_CHECK; i++) {
                loader.load(
                    `${i}.JPG`, 
                    (tex) => { processLoadedTexture(tex); }, 
                    undefined, 
                    (err) => {
                        loader.load(
                            `${i}.jpg`,
                            (tex) => { processLoadedTexture(tex); },
                            undefined,
                            (err2) => { checkAllChecked(); }
                        );
                    }
                );
            }
        }
        
        let sceneState = 'OPENING'; 

        function playIntro() {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.opacity = 0; 
            setTimeout(() => loadingEl.style.display = 'none', 500);
            document.getElementById('ui-container').style.opacity = 1;
            document.getElementById('video-container').style.display = 'block';

            particles.forEach(p => {
                const delay = Math.random() * 3.0;
                const duration = 2.0 + Math.random() * 2.0;
                gsap.to(p.mesh.position, { x: p.treePos.x, y: p.treePos.y, z: p.treePos.z, duration: duration, delay: delay, ease: "power2.out" });
                gsap.to(p.mesh.scale, { x: p.finalScale.x, y: p.finalScale.y, z: p.finalScale.z, duration: 1.5, delay: delay, ease: "back.out(1.2)" });
                if (p.isImage) {
                    p.mesh.rotation.z = Math.random() * Math.PI;
                    gsap.to(p.mesh.rotation, { z: 0, duration: duration, delay: delay });
                }
            });

            particlesGroup.children.forEach(child => {
                if(child.userData.isTopStar) {
                    child.userData.currentAlpha = 1;
                    child.userData.currentScale = 3.5; 
                    gsap.to(child.scale, { x: 3.5, y: 3.5, duration: 1.5, delay: 4.0, ease: "elastic.out(1, 0.3)" });
                    gsap.to(child.material, { opacity: 1, duration: 1, delay: 4.0 });
                }
            });

            setTimeout(() => {
                sceneState = 'TREE';
                const statusDiv = document.getElementById('status');
                statusDiv.innerText = "âœŠ æ¡æ‹³: è—å…¥å¿ƒåº• | ğŸ– å¼ å¼€: å¤§å£°è¯´çˆ±ä½ ";
                statusDiv.style.background = "rgba(50, 50, 60, 0.4)";
                gsap.from(statusDiv, { scale: 1.2, duration: 0.3, yoyo: true, repeat: 1 });
            }, 8500); 
        }

        let isPinching = false;
        let rotationSpeed = 0.005; 
        const BASE_SPEED = 0.005;
        let lastPalmX = null; 
        let heldParticle = null; 

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            starMaterial.uniforms.uTime.value = time;
            water.material.uniforms['time'].value += 1.0 / 60.0;
            centerLight.position.x = Math.sin(time * 0.5) * 3;
            centerLight.position.z = 5 + Math.cos(time * 0.3) * 2;

            if (sceneState !== 'OPENING') {
                particlesGroup.children.forEach(child => {
                    if(child.userData.isTopStar) {
                        let targetAlpha = 1.0;
                        let targetScale = 3.5; 
                        if (sceneState === 'EXPLODE') { targetAlpha = 0.0; targetScale = 0.0; }
                        if (typeof child.userData.currentAlpha === 'undefined') child.userData.currentAlpha = 0;
                        if (typeof child.userData.currentScale === 'undefined') child.userData.currentScale = 3.5;
                        child.userData.currentAlpha += (targetAlpha - child.userData.currentAlpha) * 0.02;
                        child.userData.currentScale += (targetScale - child.userData.currentScale) * 0.02;
                        child.scale.set(child.userData.currentScale, child.userData.currentScale, 1);
                        child.rotation.z = Math.sin(time) * 0.1;
                        child.material.opacity = (0.8 + Math.sin(time * 3) * 0.2) * child.userData.currentAlpha;
                    }
                });
            }

            if (!heldParticle) {
                particlesGroup.rotation.y += rotationSpeed;
                if (sceneState === 'EXPLODE') { rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, 0, 0.05); } 
                else { rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, BASE_SPEED, 0.05); }
            }

            particles.forEach((p) => {
                if (sceneState === 'OPENING') return;
                if (p.state === 'grabbed') { p.mesh.lookAt(camera.position); return; }
                const target = (sceneState === 'TREE') ? p.treePos : p.textPos;
                p.mesh.position.lerp(target, 0.05);
                if (p.isImage) {
                    const baseS = (sceneState === 'TREE') ? 0.015 : 0.8; 
                    p.mesh.scale.lerp(new THREE.Vector3(baseS * p.ratio, baseS, baseS), 0.1);
                    p.mesh.lookAt(camera.position); 
                } 
            });
            composer.render();
        }
        animate();

        const videoElement = document.getElementById('input-video');
        const statusDiv = document.getElementById('status');
        
        function onResults(results) {
            if (sceneState === 'OPENING') return;
            if (!results.multiHandLandmarks?.length) {
                lastPalmX = null;
                if (heldParticle) releaseCurrentParticle();
                return;
            }

            const lm = results.multiHandLandmarks[0];
            const thumb = lm[4];
            const index = lm[8];
            const wrist = lm[0];
            const currentPalmX = lm[9].x; 

            if (lastPalmX !== null && !isPinching) {
                const deltaX = currentPalmX - lastPalmX;
                if (Math.abs(deltaX) > 0.002) rotationSpeed -= deltaX * 0.8; 
            }
            lastPalmX = currentPalmX;

            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            let spread = 0;
            [lm[8], lm[12], lm[16], lm[20]].forEach(t => spread += Math.hypot(t.x - wrist.x, t.y - wrist.y));
            spread /= 4;

            if (!isPinching) {
                if (spread < 0.22) { sceneState = 'TREE'; } 
                else { sceneState = 'EXPLODE'; }
            }

            if (pinchDist < 0.05) {
                if (sceneState === 'EXPLODE') {
                    isPinching = true;
                    if (!heldParticle) grabNewParticle();
                }
            } else {
                isPinching = false;
                if (heldParticle) releaseCurrentParticle();
            }

            if (sceneState === 'TREE') {
                statusDiv.innerText = "ğŸ– å¼ å¼€ï¼šå¤§å£°è¯´çˆ±ä½ ";
                statusDiv.style.background = "rgba(50, 50, 60, 0.4)";
            } else {
                if (isPinching) {
                    statusDiv.innerText = "ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç¾å¥½ç¬é—´";
                    statusDiv.style.background = "rgba(200, 200, 200, 0.3)";
                } else {
                    statusDiv.innerText = "âœŠ æ¡æ‹³ï¼šè—å…¥å¿ƒåº• | ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç…§ç‰‡";
                    statusDiv.style.background = "rgba(180, 50, 80, 0.6)";
                }
            }
        }

        function grabNewParticle() {
            let candidates = particles.filter(p => p.isImage && p.state === 'free');
            if (candidates.length === 0) candidates = particles.filter(p => p.state === 'free');
            if (candidates.length > 0) {
                const p = candidates[Math.floor(Math.random() * candidates.length)];
                p.state = 'grabbed';
                heldParticle = p;
                scene.attach(p.mesh); 
                if (p.isImage) {
                    p.mesh.traverse((child) => {
                        if (child.isMesh) { child.renderOrder = 9999; child.material.depthTest = false; }
                    });
                } else {
                    p.mesh.renderOrder = 9999; p.mesh.material.depthTest = false;
                }
                const zoomScale = 12;
                gsap.to(p.mesh.position, { x: 0, y: 4, z: 20, duration: 0.8, ease: "back.out(1.2)" });
                if (p.isImage) {
                    gsap.to(p.mesh.rotation, { x: 0, y: 0, z: 0, duration: 0.5 });
                    gsap.to(p.mesh.scale, { x: zoomScale * p.ratio, y: zoomScale, z: zoomScale, duration: 0.8 }); 
                } else {
                    gsap.to(p.mesh.scale, { x: 8, y: 8, z: 8, duration: 0.8 });
                }
            }
        }

        function releaseCurrentParticle() {
            if (!heldParticle) return;
            const p = heldParticle;
            p.state = 'free';
            heldParticle = null;
            if (p.isImage) {
                p.mesh.traverse((child) => {
                    if (child.isMesh) { child.renderOrder = 0; child.material.depthTest = true; }
                });
            } else {
                p.mesh.renderOrder = 0; p.mesh.material.depthTest = true;
            }
            particlesGroup.attach(p.mesh);
            const baseS = p.isImage ? (sceneState==='EXPLODE'? 0.8 : 0.015) : (0.2 + Math.random()*0.5);
            if (p.isImage) {
                 gsap.to(p.mesh.scale, { x: baseS * p.ratio, y: baseS, z: baseS, duration: 0.6, ease: "power2.out" });
            } else {
                 gsap.to(p.mesh.scale, { x: baseS, y: baseS, z: baseS, duration: 0.6, ease: "power2.out" });
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        requestAnimationFrame(processVideo);
                        resolve();
                    };
                });
            } catch (err) {
                console.warn("Camera access denied:", err);
                const statusDiv = document.getElementById('status');
                if(statusDiv) statusDiv.innerText = "â­ ä»…ä¾›è§‚èµ (æ‘„åƒå¤´æœªæˆæƒ)";
                return Promise.resolve();
            }
        }

        let lastVideoTime = 0;
        async function processVideo() {
            if (videoElement.paused || videoElement.ended) return;
            
            const now = Date.now();
            if (now - lastVideoTime > 100) {
                if (videoElement.readyState >= 2) {
                    await hands.send({image: videoElement});
                }
                lastVideoTime = now;
            }
            requestAnimationFrame(processVideo);
        }

        window.addEventListener('resize', () => {
            adjustCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
            water.material.uniforms.textureMatrix.value.set(0.5, 0, 0, 0, 0.5, 0.5, 0, 0, 0, 0.5, 0.5, 0, 0, 0, 0, 1);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>